module IOFSM;
bit CLK;
bit MNMX;
bit TEST;
bit RESET;
bit READY;
bit NMI ;
bit INTR;
bit HOLD;
logic [7:0] AD;
logic [19:8] A;
logic CS;
logic OE;
logic HLDA;
logic IOM;
logic WR;
logic RD;
logic SSO;
logic INTA;
logic ALE;
logic DTR;
logic DEN;
logic CLK;
int cpu_time;
logic [7:0] memory [0:1048575];
logic [19:0] Address;
logic [7:0]  Data;
typedef enum logic [4:0] {
    IDLE = 5'b00001,
    VALID = 5'b00010,
    READ = 5'b00100,
    WRITE = 5'b01000,
    HALT = 5'b10000,
} State_t;

State_t State, NextState;

always begin
    CLK = #50 ~CLK;
end
always @(posedge CLK) begin
cpu_time=cpu_time+1;
end
initial begin
	cpu_time=0;
	CLK = '0;
    MNMX = '1;
	TEST = '1;
	RESET = '0;
	READY = '1;
	NMI = '0;
	INTR = '0;
	HOLD = '0;
end


always_ff @(posedge CLK) 
begin
if (RESET)
	State <= IDLE;	
else
	State <= NextState;
end

// next state combinational block
if(IOM==ACTIVE) begin

	always_comb 
	begin
	case (State)
	NextState = State;
		IDLE:	if(ALE)
					NextState = VALID;
					
		VALID:	if(!RD) 
					NextState = READ;
				else 
					NextState = WRITE;

		READ:  NextState = HALT;
		
		WRITE: NextState = HALT;
		
		HALT:	NextState = VALID; 	

	endcase
	end

	//output combinational block
	always_comb
	begin
		IDLE:	
					
		VALID:	
		
		READ:	begin
					Data=Memory[Address];
					OE='1;
				end
		
		WRITE:	begin
					Memory[Address]=cpu_time & 0xff;
					OE='0;
				end
		
		HALT:	begin
					Data=1'bz;
				end
		
	end
end
else begin

	always_comb 
	begin
	case (State)
	NextState = State;
		IDLE:	if(ALE)
					NextState = VALID;
					
		VALID:	if(!RD) 
					NextState = READ;
				else 
					NextState = WRITE;

		READ:  NextState = HALT;
		
		WRITE: NextState = HALT;
		
		HALT:	NextState = VALID; 	

	endcase
	end

	//output combinational block
	always_comb
	begin
		IDLE:	
					
		VALID:	
		
		READ:	begin
					Data=Memory[Address];		
				end
		
		WRITE:	begin
					Memory[Address]=Data;
				end
		
		HALT:	begin
					Data=1'bz;
				end
		
	end
end


endmodule
